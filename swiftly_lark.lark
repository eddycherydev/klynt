// Swiftly grammar for Lark parser
%import common.WS
%import common.ESCAPED_STRING
%ignore WS

LBRACE: "{"
RBRACE: "}"
COLON: ":"
COMMA: ","

?start: statement+

?statement: variable_decl
          | assignment
          | function_decl
          | class_decl
          | if_stmt
          | while_stmt
          | for_stmt
          | return_stmt
          | expression_stmt
          | import_stmt
          | try_stmt
          | raise_stmt

variable_decl: "let" IDENTIFIER "=" expression

assignment: (member_access | IDENTIFIER) "=" expression

function_decl: "func" IDENTIFIER "(" param_list? ")" block

class_decl: "class" IDENTIFIER ("extends" IDENTIFIER)? block

import_stmt: "import" STRING

if_stmt: "if" expression block ("else" block)?

while_stmt: "while" expression block

for_stmt: "for" IDENTIFIER "in" expression block

return_stmt: "return" expression?

expression_stmt: expression

try_stmt: "try" block "catch" IDENTIFIER block

raise_stmt: "raise" expression

param_list: IDENTIFIER ("," IDENTIFIER)*

?expression: dict_literal
           | logic_or

?logic_or: logic_and
          | logic_or "or" logic_and   -> or_op

?logic_and: equality
          | logic_and "and" equality  -> and_op

?equality: comparison
         | equality "==" comparison   -> eq_op
         | equality "!=" comparison   -> neq_op

?comparison: term
           | comparison "<" term      -> lt_op
           | comparison "<=" term     -> le_op
           | comparison ">" term      -> gt_op
           | comparison ">=" term     -> ge_op

?term: factor
     | term "+" factor                -> add
     | term "-" factor                -> sub

?factor: unary
       | factor "*" unary             -> mul
       | factor "/" unary             -> div
       | factor "%" unary             -> mod

?unary: "!" unary                     -> not_op
      | "-" unary                     -> neg
      | call

?call: member_access ("(" arg_list? ")")*

member_access: primary ("." IDENTIFIER)*

arg_list: expression ("," expression)*

?primary: NUMBER                     -> number
        | STRING                     -> string
        | "true"                     -> true
        | "false"                    -> false
        | "null"                     -> null
        | IDENTIFIER                 -> var
        | array_literal
        | set_literal
        | "(" expression ")"

array_literal: "[" [expression ("," expression)*] "]"

set_literal: "Set" "(" [expression ("," expression)*] ")"

block: "{" statement* "}"

dict_literal: "{" [pair ("," pair)*] "}"
pair: expression ":" expression

NUMBER: /\d+(\.\d+)?/
STRING: /"(?:\\.|[^"])*"/

IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/

%ignore /[ \t\r\n]+/
%ignore /\/\/[^\n]*/